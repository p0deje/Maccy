import AppKit
import Defaults
import Sauce

class Clipboard {
    static let shared = Clipboard()

    typealias OnNewCopyHook = (HistoryItem) -> Void

    private var onNewCopyHooks: [OnNewCopyHook] = []
    var changeCount: Int

    private let pasteboard = NSPasteboard.general

    var newCopyStream: AsyncStream<Int> {
        AsyncStream { continuation in
            let task = Task(priority: .background) {
                var lastChangeCount = self.changeCount
                while !Task.isCancelled {
                    try? await Task.sleep(
                        nanoseconds: UInt64(Defaults[.clipboardCheckInterval] * 1_000_000_000))
                    let currentChangeCount = self.pasteboard.changeCount
                    if currentChangeCount != lastChangeCount {
                        lastChangeCount = currentChangeCount
                        continuation.yield(currentChangeCount)
                    }
                }
            }
            continuation.onTermination = { _ in
                task.cancel()
            }
        }
    }

    private let dynamicTypePrefix = "dyn."
    private let microsoftSourcePrefix = "com.microsoft.ole.source."
    private let supportedTypes: Set<NSPasteboard.PasteboardType> = [
        .fileURL,
        .html,
        .jpeg,
        .heic,
        .png,
        .rtf,
        .string,
        .tiff,
    ]
    internal let ignoredTypes: Set<NSPasteboard.PasteboardType> = [
        .autoGenerated,
        .concealed,
        .transient,
    ]

    internal var enabledTypes: Set<NSPasteboard.PasteboardType> {
        Defaults[.enabledPasteboardTypes]
    }
    internal var disabledTypes: Set<NSPasteboard.PasteboardType> {
        supportedTypes.subtracting(enabledTypes)
    }

    internal var sourceApp: NSRunningApplication? { NSWorkspace.shared.frontmostApplication }

    // Image file extensions that we should load as image data
    internal let imageFileExtensions: Set<String> = [
        "jpg", "jpeg", "png", "gif", "bmp", "tiff", "tif", "heic", "heif", "webp",
    ]

    init() {
        changeCount = pasteboard.changeCount
    }

    func onNewCopy(_ hook: @escaping OnNewCopyHook) {
        onNewCopyHooks.append(hook)
    }

    func clearHooks() {
        onNewCopyHooks = []
    }

    @MainActor
    func copy(_ string: String) {
        pasteboard.clearContents()
        pasteboard.setString(string, forType: .string)
        sync()
        checkForChangesInPasteboard()
    }

    @MainActor
    func copy(_ item: HistoryItem?, removeFormatting: Bool = false) {
        guard let item else { return }

        pasteboard.clearContents()
        var contents = item.contents

        if removeFormatting {
            contents = clearFormatting(contents)
        }

        let pasteboardItems = contents.compactMap { content -> NSPasteboardItem? in
            guard let data = content.value else { return nil }
            let item = NSPasteboardItem()
            item.setData(data, forType: NSPasteboard.PasteboardType(content.type))
            return item
        }

        pasteboard.writeObjects(pasteboardItems)
        pasteboard.setString("", forType: .fromMaccy)
        pasteboard.setString(item.application ?? "", forType: .source)
        sync()

        Task {
            Notifier.notify(body: item.title, sound: .knock)
            checkForChangesInPasteboard()
        }
    }

    // Based on https://github.com/Clipy/Clipy/blob/develop/Clipy/Sources/Services/PasteService.swift.
    func paste() {
        Accessibility.check()

        // Add flag that left/right modifier key has been pressed.
        // See https://github.com/TermiT/Flycut/pull/18 for details.
        let cmdFlag = CGEventFlags(rawValue: UInt64(KeyChord.pasteKeyModifiers.rawValue) | 0x000008)
        var vCode = Sauce.shared.keyCode(for: KeyChord.pasteKey)

        // Force QWERTY keycode when keyboard layout switches to
        // QWERTY upon pressing ⌘ key (e.g. "Dvorak - QWERTY ⌘").
        // See https://github.com/p0deje/Maccy/issues/482 for details.
        if KeyboardLayout.current.commandSwitchesToQWERTY && cmdFlag.contains(.maskCommand) {
            vCode = KeyChord.pasteKey.QWERTYKeyCode
        }

        let source = CGEventSource(stateID: .combinedSessionState)
        // Disable local keyboard events while pasting
        source?.setLocalEventsFilterDuringSuppressionState(
            [.permitLocalMouseEvents, .permitSystemDefinedEvents],
            state: .eventSuppressionStateSuppressionInterval)

        let keyVDown = CGEvent(keyboardEventSource: source, virtualKey: vCode, keyDown: true)
        let keyVUp = CGEvent(keyboardEventSource: source, virtualKey: vCode, keyDown: false)
        keyVDown?.flags = cmdFlag
        keyVUp?.flags = cmdFlag
        keyVDown?.post(tap: .cgSessionEventTap)
        keyVUp?.post(tap: .cgSessionEventTap)
    }

    func clear() {
        guard Defaults[.clearSystemClipboard] else {
            return
        }

        pasteboard.clearContents()
    }

    @objc
    func checkForChangesInPasteboard() {  // swiftlint:disable:this function_body_length
        guard pasteboard.changeCount != changeCount else {
            return
        }

        // Immediately update changeCount on the main thread to avoid re-triggering.
        self.changeCount = pasteboard.changeCount

        Task(priority: .background) {
            let changeCount = self.changeCount
            let sourceApp = self.sourceApp
            let pasteboardItems = pasteboard.pasteboardItems ?? []

            if await self.shouldIgnore(Set(pasteboard.types ?? [])) {
                return
            }

            if let sourceAppBundle = sourceApp?.bundleIdentifier,
                await self.shouldIgnore(sourceAppBundle)
            {
                return
            }

            var contents = [HistoryItemContent]()
            for item in pasteboardItems {
                if await self.shouldIgnore(item) {
                    continue
                }

                var types = Set(item.types)
                if types.contains(.string) && self.isEmptyString(item) && !self.richText(item) {
                    continue
                }

                types = await MainActor.run {
                    types
                        .subtracting(disabledTypes)
                        .filter { !$0.rawValue.starts(with: dynamicTypePrefix) }
                        .filter { !$0.rawValue.starts(with: microsoftSourcePrefix) }
                }

                if types.isSuperset(of: [.microsoftLinkSource, .microsoftObjectLink]) {
                    types = types.subtracting([.microsoftLinkSource, .microsoftObjectLink, .pdf])
                }

                for type in types {
                    if let data = item.data(forType: type) {
                        contents.append(HistoryItemContent(type: type.rawValue, value: data))
                    }
                }
            }

            guard !contents.isEmpty else {
                return
            }

            self.addImageDataFromFileURLs(&contents)

            let newItem = await MainActor.run {
                let historyItem = HistoryItem()
                Storage.shared.context.insert(historyItem)
                historyItem.contents = contents
                historyItem.application = sourceApp?.bundleIdentifier
                historyItem.title = historyItem.generateTitle()
                return historyItem
            }

            await MainActor.run {
                self.onNewCopyHooks.forEach({ $0(newItem) })
            }
        }
    }

    @MainActor
    private func shouldIgnore(_ types: Set<NSPasteboard.PasteboardType>) -> Bool {
        let ignoredTypes = self.ignoredTypes
            .union(Defaults[.ignoredPasteboardTypes].map({ NSPasteboard.PasteboardType($0) }))

        return types.isDisjoint(with: enabledTypes) || !types.isDisjoint(with: ignoredTypes)
    }

    @MainActor
    private func shouldIgnore(_ sourceAppBundle: String) -> Bool {
        if Defaults[.ignoreAllAppsExceptListed] {
            return !Defaults[.ignoredApps].contains(sourceAppBundle)
        } else {
            return Defaults[.ignoredApps].contains(sourceAppBundle)
        }
    }

    @MainActor
    private func shouldIgnore(_ item: NSPasteboardItem) -> Bool {
        if item.types.contains(.fromMaccy) {
            return true
        }

        for regexp in Defaults[.ignoreRegexp] {
            if let string = item.string(forType: .string) {
                do {
                    let regex = try NSRegularExpression(pattern: regexp)
                    if regex.numberOfMatches(
                        in: string, range: NSRange(string.startIndex..., in: string)) > 0
                    {
                        return true
                    }
                } catch {
                    return false
                }
            }
        }
        return false
    }

    private func isEmptyString(_ item: NSPasteboardItem) -> Bool {
        return (item.string(forType: .string) ?? "").trimmingCharacters(in: .whitespacesAndNewlines)
            .isEmpty
    }

    private func richText(_ item: NSPasteboardItem) -> Bool {
        return item.data(forType: .rtf) != nil || item.data(forType: .html) != nil
    }
}

// MARK: - Copy and Paste Operations Extensions
extension Clipboard {
    func clearFormatting(_ contents: [HistoryItemContent]) -> [HistoryItemContent] {
        var newContents: [HistoryItemContent] = contents
        let stringContents = contents.filter { NSPasteboard.PasteboardType($0.type) == .string }

        // If there is no string representation of data,
        // behave like we didn't have to remove formatting.
        if !stringContents.isEmpty {
            newContents = stringContents

            // Preserve file URLs.
            // https://github.com/p0deje/Maccy/issues/962
            let fileURLContents = contents.filter {
                NSPasteboard.PasteboardType($0.type) == .fileURL
            }
            if !fileURLContents.isEmpty {
                newContents += fileURLContents
            }
        }

        return newContents
    }

    // Some applications requires window be unfocused and focused back to sync the clipboard.
    // - Chrome Remote Desktop (https://github.com/p0deje/Maccy/issues/948)
    // - Netbeans (https://github.com/p0deje/Maccy/issues/879)
    func sync() {
        guard let app = sourceApp,
            app.bundleURL?.lastPathComponent == "Chrome Remote Desktop.app"
                || app.localizedName?.contains("NetBeans") == true
        else {
            return
        }

        NSApp.activate(ignoringOtherApps: true)
        NSApp.hide(self)
    }
}

// MARK: - Image File Handling Extensions
extension Clipboard {
    func isImageFile(_ url: URL) -> Bool {
        let fileExtension = url.pathExtension.lowercased()
        return imageFileExtensions.contains(fileExtension)
    }

    func loadImageDataFromFileURL(_ url: URL) -> Data? {
        guard isImageFile(url), FileManager.default.fileExists(atPath: url.path) else {
            return nil
        }

        return try? Data(contentsOf: url)
    }

    func addImageDataFromFileURLs(_ contents: inout [HistoryItemContent]) {
        // Find file URL contents
        let fileURLContents = contents.filter { NSPasteboard.PasteboardType($0.type) == .fileURL }

        for fileURLContent in fileURLContents {
            guard let urlData = fileURLContent.value,
                let url = URL(dataRepresentation: urlData, relativeTo: nil, isAbsolute: true),
                let imageData = loadImageDataFromFileURL(url)
            else {
                continue
            }

            // Determine the appropriate pasteboard type based on file extension
            let fileExtension = url.pathExtension.lowercased()
            let pasteboardType: NSPasteboard.PasteboardType

            switch fileExtension {
            case "jpg", "jpeg":
                pasteboardType = .jpeg
            case "png":
                pasteboardType = .png
            case "tif", "tiff":
                pasteboardType = .tiff
            case "heic", "heif":
                pasteboardType = .heic
            default:
                // For other image types, convert to TIFF as a fallback
                if let nsImage = NSImage(data: imageData) {
                    if let tiffData = nsImage.tiffRepresentation {
                        contents.append(
                            HistoryItemContent(
                                type: NSPasteboard.PasteboardType.tiff.rawValue,
                                value: tiffData
                            ))
                    }
                }
                continue
            }

            // Add the image data as the appropriate type
            contents.append(HistoryItemContent(type: pasteboardType.rawValue, value: imageData))
        }
    }
}
